#![allow(dead_code)]

use crate::shell_ast::{Expression, Function, InterpolationPart, ShellAst, Statement, Test};
use std::fmt::Write;

pub fn emit_deterministic(ast: &ShellAst) -> String {
    let mut output = String::with_capacity(4096);

    // Emit header with deterministic metadata
    writeln!(output, "#!/bin/sh").unwrap();
    writeln!(output, "# Generated by paiml-mcp-agent-toolkit").unwrap();
    writeln!(output, "# Build: {}", env!("CARGO_PKG_VERSION")).unwrap();

    let hash = ast.compute_hash();
    let hash_hex = hash.iter().fold(String::new(), |mut acc, b| {
        write!(acc, "{:02x}", b).unwrap();
        acc
    });
    writeln!(output, "# SHA256: {}", hash_hex).unwrap();
    writeln!(output, "set -euf").unwrap();
    writeln!(output).unwrap();

    // Emit constants in deterministic order
    let ShellAst::Script {
        constants,
        functions,
        main,
    } = ast;
    if !constants.is_empty() {
        writeln!(output, "# Constants").unwrap();
        for (content, id) in constants {
            writeln!(output, "readonly S{}=\"{}\"", id, shell_escape(content)).unwrap();
        }
        writeln!(output).unwrap();
    }

    // Emit functions
    for func in functions {
        emit_function(&mut output, func);
    }

    // Emit main logic
    writeln!(output, "# Main").unwrap();
    writeln!(output, "main() {{").unwrap();

    for stmt in main {
        emit_statement(&mut output, stmt, 1);
    }

    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
    writeln!(output, "main \"$@\"").unwrap();

    output
}

fn emit_function(output: &mut String, func: &Function) {
    writeln!(output, "{}() {{", func.name).unwrap();
    for stmt in &func.body {
        emit_statement(output, stmt, 1);
    }
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

fn emit_statement(output: &mut String, stmt: &Statement, indent: usize) {
    let indent_str = "    ".repeat(indent);

    match stmt {
        Statement::Assignment { var, value } => {
            writeln!(output, "{}{}={}", indent_str, var, emit_expression(value)).unwrap();
        }
        Statement::LocalAssignment { var, value } => {
            writeln!(
                output,
                "{}local {}={}",
                indent_str,
                var,
                emit_expression(value)
            )
            .unwrap();
        }
        Statement::Command { cmd, args } => {
            write!(output, "{}{}", indent_str, cmd).unwrap();
            for arg in args {
                write!(output, " {}", emit_expression(arg)).unwrap();
            }
            writeln!(output).unwrap();
        }
        Statement::Conditional {
            test,
            then_block,
            else_block,
        } => {
            writeln!(output, "{}if {}; then", indent_str, emit_test(test)).unwrap();
            for stmt in then_block {
                emit_statement(output, stmt, indent + 1);
            }
            if let Some(else_stmts) = else_block {
                writeln!(output, "{}else", indent_str).unwrap();
                for stmt in else_stmts {
                    emit_statement(output, stmt, indent + 1);
                }
            }
            writeln!(output, "{}fi", indent_str).unwrap();
        }
        Statement::Case { expr, patterns } => {
            writeln!(output, "{}case {} in", indent_str, emit_expression(expr)).unwrap();
            for (pattern, stmts) in patterns {
                writeln!(output, "{}    {})", indent_str, pattern).unwrap();
                for stmt in stmts {
                    emit_statement(output, stmt, indent + 2);
                }
                writeln!(output, "{}        ;;", indent_str).unwrap();
            }
            writeln!(output, "{}esac", indent_str).unwrap();
        }
        Statement::Exit { code } => {
            writeln!(output, "{}exit {}", indent_str, code).unwrap();
        }
        Statement::Return { code } => {
            writeln!(output, "{}return {}", indent_str, code).unwrap();
        }
        Statement::Comment { text } => {
            writeln!(output, "{}# {}", indent_str, text).unwrap();
        }
        Statement::If {
            condition,
            then_block,
            else_block,
        } => {
            writeln!(output, "{}if {}; then", indent_str, condition).unwrap();
            for stmt in then_block {
                emit_statement(output, stmt, indent + 1);
            }
            if let Some(else_stmts) = else_block {
                writeln!(output, "{}else", indent_str).unwrap();
                for stmt in else_stmts {
                    emit_statement(output, stmt, indent + 1);
                }
            }
            writeln!(output, "{}fi", indent_str).unwrap();
        }
        Statement::SetTrap { command, signals } => {
            writeln!(
                output,
                "{}trap '{}' {}",
                indent_str,
                command,
                signals.join(" ")
            )
            .unwrap();
        }
    }
}

fn emit_expression(expr: &Expression) -> String {
    match expr {
        Expression::Literal(s) => format!("\"{}\"", shell_escape(s)),
        Expression::Variable(v) => format!("${{{}}}", v),
        Expression::CommandSubstitution { command, args } => {
            let mut cmd = format!("$({}", command);
            for arg in args {
                cmd.push(' ');
                cmd.push_str(&format!("\"{}\"", shell_escape(arg)));
            }
            cmd.push(')');
            cmd
        }
        Expression::Concat(parts) => parts
            .iter()
            .map(emit_expression)
            .collect::<Vec<_>>()
            .join(""),
        Expression::StringInterpolation { parts } => {
            let mut result = String::new();
            result.push('"');
            for part in parts {
                match part {
                    InterpolationPart::Literal(s) => result.push_str(&shell_escape(s)),
                    InterpolationPart::Variable(v) => {
                        result.push_str(&format!("${{{}}}", v));
                    }
                }
            }
            result.push('"');
            result
        }
    }
}

fn emit_test(test: &Test) -> String {
    match test {
        Test::FileExists(path) => format!("[ -f \"{}\" ]", shell_escape(path)),
        Test::DirectoryExists(path) => format!("[ -d \"{}\" ]", shell_escape(path)),
        Test::StringEquals(a, b) => {
            format!("[ \"{}\" = \"{}\" ]", shell_escape(a), shell_escape(b))
        }
        Test::StringNotEquals(a, b) => {
            format!("[ \"{}\" != \"{}\" ]", shell_escape(a), shell_escape(b))
        }
        Test::CommandSuccess(cmd, args) => {
            let mut result = cmd.clone();
            for arg in args {
                result.push(' ');
                result.push_str(&format!("\"{}\"", shell_escape(arg)));
            }
            result
        }
        Test::Not(inner) => format!("! {}", emit_test(inner)),
    }
}

fn shell_escape(s: &str) -> String {
    s.chars()
        .map(|c| match c {
            '"' => "\\\"".to_string(),
            '\\' => "\\\\".to_string(),
            '$' => "\\$".to_string(),
            '`' => "\\`".to_string(),
            '\n' => "\\n".to_string(),
            '\r' => "\\r".to_string(),
            '\t' => "\\t".to_string(),
            c if c.is_control() => format!("\\x{:02x}", c as u8),
            c => c.to_string(),
        })
        .collect()
}
